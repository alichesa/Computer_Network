# 计算机网络八股
- 在数据链路层是用MAC寻找对方主机（局域网），端口是在传输层中寻找设备的（是为了区分同一个主机上不同应用程序的数据包）

- 信号是一种通知机制，能够处理异步事件，一般是用来通知进程有事件发生； 信号量是用于进程\线程同步或异步的计数器，用来协调多个线程\进程对资源的访问

- TCP（TCP 是面向连接的、可靠的、基于字节流的传输层通信协议）是面向字节流的协议，其传输结果是不会改变。UDP是面向于报文的协议，相较于TCP速度较快，但是不安全，对方不一定能接收到。UDP最大只有512个字节。 UDP不会对信息进行拆分，直接传输给对方，用队列进行存储。因为TCP不保留报文边界，所以TCP会有拆包和黏包的情况，针对这个情况可以用特殊符号作为边界确认符

- 应用层主要以应用软件为主，然后将应用数据传送至传输层；传输层就是有两个主要的传输协议TCP和UDP，若传送的数据大于TCP最大报文长度（MTU=1500）则将TCP进行分段处理，每一段为TCP段，TCP报文中会含有端口信息用于区分一个设备不同的传输操作；然后将加了TCP头部的报文给网络层加IP协议组成IP报文；进而在网络接口层加以MAC头部进行封装成数据帧传送至网络上
![Pasted image 20250529091013](https://github.com/user-attachments/assets/0a23475a-076e-44e7-83d2-da2bc472407a)

- TCP分段 - 应用层的数据大于MSS（Maximum Segment Size），因此在TCP这层就会进行拆分；IP分段 - IP报文长度超过MTU（Maximum Transmission Unit）

- socket主要是将应用层数据和TCP IP进行连接
<img width="926" height="605" alt="image" src="https://github.com/user-attachments/assets/40aa139a-b39e-4f4d-8498-96431b7ea207" />

- TCP三次握手 同步  同步+已知  已知
![Pasted image 20250626220044](https://github.com/user-attachments/assets/17cdd982-2f02-407c-ab93-fb75a3412fd3)

- HTTP、DNS、协议栈、TCP、IP、MAC（对方的MAC地址由ARP（ARP是用于ping的时候的播报，ICMP就是用来报状态，类似是否成功）广播获得）、网卡（会有头和尾校验）、路由器；由于本地有多个网卡，因此确定所需本地网址的时候会在路由表中的路由进行与计算从而找出所需的网址。传送的IP地址始终不变，变得一直都是MAC地址
![Pasted image 20250529105127](https://github.com/user-attachments/assets/d90b8b87-81a7-494a-8cca-dd9e476c3155)

- 首先浏览器解析域名，解析成为ip地址然后与服务器通过三次握手协议建立连接，建立TCP连接后进行HTTP请求，服务器返回HTTP代码，然后浏览器对代码进行解析渲染，完成之后就需要进行释放，也就是四次挥手

- 三次握手 - ​​ABA 问题本质​​：假设客户端发送 SYN=1（序列号=x）后，因网络延迟未到达服务器。客户端超时重发 SYN=1（序列号=y），此时：如果只有两次握手，​​延迟的旧 SYN(x)​​ 可能被服务器误认为是新连接请求，导致资源浪费； 四次挥手- TCP 是全双工协议，一方发送完数据后（如 FIN），仍可能需接收对方数据，因此需要等待B发送完数据，所以才需要四次。

- DNS是域名系统，是域名和IP转换的工具。主要是用于解析客户端发出的DNS请求。一般先去缓存看有没有对应的，然后再去hosts文件看看，最后才利用DNS系统。具体实现流程是--首先会在本地DNS中寻找缓存，如果本地DNS没有缓存那么就会去根域寻找，根域会提供顶级域（返回 .com顶级域服务器的地址），顶级域提供权威域（返回 example.com的权威 DNS 服务器地址），权威域返回ip（www.example.com）
![Pasted image 20250529094833](https://github.com/user-attachments/assets/2c65e357-a173-4713-aa6b-185f95d8b537)

- get的请求放在了URL上面，而post的请求放在了BODY里面，并非是对get的请求做了限制，而是因为浏览器有这对URL的字符限制。get是将head和body一起发送，然后服务器返回200。post是head和body分开发送，先返回100再返回200。get是幂等性操作，因此不能进行删、改、增操作。GET 的数据限制来自浏览器（URL 长度），而非 HTTP 协议，POST 的 Body 无协议限制，但服务器可能拒绝过大请求（如 Nginx 默认限制 1MB）。

- HTTP会通过缓存进行速度优化。强制缓存（无需与服务器通信，速度最快）是指浏览器第一次访问服务器的时候服务器返回的字段中会有缓存字段并设置了缓存过期时间。协商缓存（本地存储的资源已经过期，若发现服务器的资源和本地资源一样，那就启动协商缓存）（需一次 HTTP 请求，节省带宽）就是和服务器协商之后是否使用本地的缓存。

- cookie的出现主要是http是无状态的协议，cookie将服务器返回的数据存在本地，然后下次发送请求的时候一并发送过去用以身份确认，cookie是在用户端，session是在服务器端，服务器端创建好后会返回给客户端sessionid，然后下次传输就会附带
1. 用户登录 → 服务器创建 Session（存用户数据） → 返回 `Set-Cookie: JSESSIONID=xyz789`。
2. 浏览器携带 `Cookie: JSESSIONID=xyz789` → 服务器通过 `session_id` 读取用户数据。
3. 用户注销 → 服务器删除 Session。

- https是一种加密的传输，因为其含有SSL，从http变成https后端口会从80变成443
![Pasted image 20250530154936](https://github.com/user-attachments/assets/2b4f2c70-4744-4701-ba13-fc51cfa8e1c9)

- 对称加密是同时使用公钥进行加密，非对称是同时使用公用和私用密钥。SSL/TLS协议的基本思路是客户端向服务器索要公钥，然后客户端用公钥加密信息，服务器收到密文后用私钥解密
  在SSL/TLS协议中，非对称加密用于身份验证和密钥交换，而对称加密用于实际数据的加密传输。这种结合利用了非对称加密的安全性和对称加密的效率
  公钥加密私钥解密是为了内容不被泄露，私钥加密公钥解密是为了内容不被冒充
<img width="921" height="1082" alt="image" src="https://github.com/user-attachments/assets/68c32671-2057-4950-b704-97aa4f4cc52e" />
<img width="1002" height="500" alt="image" src="https://github.com/user-attachments/assets/133d3caf-1308-419b-83a2-892e8cc3bff8" />

- 密钥的传递是非对称加密，但是会话是对称加密

- TLS是SSL（都是属于加密协议名称，而RSA和ECDHE是属于加密方式）的后续版本，也是目前的主流版本，它是在建立HTTP连接后的加密方式，它会通过服务器和客户端生成的随机数进而利用公钥私钥产生会话密钥（原因是因为它属于非对称加密，因此只能用公钥加密，私钥解密）

- HTTP优化最简单的就是避免HTTP请求，通过缓存可以做到。其次就是减少访问次数（减少重定向--让代理服务器进行消息的传递，合并请求，延迟发送请求）

- RSA握手--首先是客户端发起，带有随机数，然后服务器回答带有随机数和证书，客户端验证继续生成随机数，再服务器收到后生成会话密钥  ECDHE握手 -- 客户端发送支持的曲线、客户端随机数，服务器返回随机数ECDHE公钥参数（服务端临时公钥！！！），客户端生成 ​​临时 ECDHE 公钥​​，与服务端的公钥通过 ​​椭圆曲线 Diffie-Hellman（ECDH）​​ 计算共享密钥（Shared Secret）、用 Client Random+ Server Random+ Shared Secret生成 ​​会话密钥​​（Master Secret），服务端用私钥和客户端的临时公钥计算相同的 Shared Secret，完成

- RSA算法不支持前向保密（若服务器私钥泄露，所有历史通信可被解密），因此有了ECDHE的诞生，主要利用了离散对数。ECDHE利用的是椭圆的性质，主要还是利用了公钥和私钥进行加密，公钥用于传递，私钥用于解密

- 传统的HTTP1.0每个请求都会建立新的TCP连接，响应完关闭，因此HTTP1.1使用了长连接，允许客户端和服务器保持持久的TCP连接，多个HTTP可以共享同一个连接。需要在connection加入keep-alive。由于有了长连接，因此就有了管道通信，可以一直发，而不是发了需要等待收，但是这个就有可能产生队头阻塞，因为可能某个请求一直接受不到。HTTP/2加了头部压缩（静态表和 Huffman 编码）的功能，同时将所有文本信息转换成二进制表示方式，可以并发传输（一个TCP可以传输多个stream，以往只能一个TCP一个stream），还有服务器主动推送资源。但HTTP2仍然有延迟，TCP与TLS之间有延迟（TCP三次握手和TLS四次握手）。HTTP3则是解决了队头阻塞，直接使用UDP进行通信。
<img width="946" height="381" alt="image" src="https://github.com/user-attachments/assets/bc21b100-e30d-433e-9914-6184d3bc0967" />

- 在Linux中若传输准备工作全部完成就会将数据放入Ring Buffer进行等待，此时出发软中断，网卡开始DMA（Direct Memory Access，直接内存访问）传输数据，若发送全部结束之后就会触发硬中断并释放内存
​​相同点​​：均通过硬件 DMA 提升 I/O 性能，减少 CPU 开销；不同点​​：Linux 更依赖软中断和 Ring Buffer，Windows 则通过 NDIS 和 DPC 抽象硬件细节。选择取决于场景需求（如 Linux 用于高性能网络，Windows 注重兼容性）。

- HTTP是计算密集型，而不是IO密集型，这代表了优化的空间主要在算力

- 裸TCP是能进行消息传递的，但是由于TCP是基于字节流的，因此会有一堆粘包的问题，因此需要将消息头和消息体分开，使用HTTP（超文本协议）--C/S架构 或者 RPC（远程过程调用）--B/S架构

- TCP 协议本身是全双工的，但我们最常用的 HTTP/1.1，虽然是基于 TCP 的协议，但它是半双工的，对于大部分需要服务器主动推送数据到客户端的场景，都不太友好，因此我们需要使用支持全双工的 WebSocket 协议（用于升级HTTP的，一旦握手成功后就能全双工）。

- TCP 和UDP 可以同一时间使用同一个端口号，因为是两个不同的逻辑端口号，数据包完整的标识是 -- 协议类型, 源IP, 源端口, 目标IP, 目标端口


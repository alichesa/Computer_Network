# 计算机网络八股
- TCP是面向字节流的协议，其传输结果是不会改变。UDP是面向于报文的协议，相较于TCP速度较快，但是不安全，对方不一定能接收到。UDP最大只有512个字节。 UDP不会对信息进行拆分，直接传输给对方，用队列进行存储。TCP会有拆包和黏包的情况，针对这个情况可以用特殊符号作为边界确认符

-  应用层主要以应用软件为主，然后将应用数据传送至传输层；传输层就是有两个主要的传输协议TCP和UDP，若传送的数据大于TCP最大报文长度（MTU=1500）则将TCP进行分段处理，每一段为TCP段，TCP报文中会含有端口信息用于区分一个设备不同的传输操作；然后将加了TCP头部的报文给网络层加IP协议组成IP报文；进而在网络接口层加以MAC头部进行封装成数据帧传送至网络上
![Pasted image 20250529091013](https://github.com/user-attachments/assets/0a23475a-076e-44e7-83d2-da2bc472407a)

- socket主要是将应用层数据和TCP IP进行连接

- TCP三次握手 同步  同步+已知  已知
![Pasted image 20250626220044](https://github.com/user-attachments/assets/17cdd982-2f02-407c-ab93-fb75a3412fd3)

- HTTP、DNS、协议栈、TCP、IP、MAC（对方的MAC地址由ARP广播获得）、网卡（会有头和尾校验）、路由器；由于本地有多个网卡，因此确定所需本地网址的时候会在路由表中的路由进行与计算从而找出所需的网址。传送的IP地址始终不变，变得一直都是MAC地址
![Pasted image 20250529105127](https://github.com/user-attachments/assets/d90b8b87-81a7-494a-8cca-dd9e476c3155)

- 首先浏览器解析域名，解析成为ip地址然后与服务器通过三次握手协议建立连接，建立TCP连接后进行HTTP请求，服务器返回HTTP代码，然后浏览器对代码进行解析渲染，完成之后就需要进行释放，也就是四次挥手

- 三次握手的原因主要为了网络延迟从而导致的某方长时间等待建立的ABA

- 四次挥手主要是一种客气挽留 ABBA
 
- DNS是域名系统，是域名和IP转换的工具。主要是用于解析客户端发出的DNS请求。一般先去缓存看有没有对应的，然后再去hosts文件看看，最后才利用DNS系统。具体实现流程是--首先会在本地DNS中寻找缓存，如果本地DNS没有缓存那么就会去根域寻找，根域会提供顶级域，顶级域提供权威域，权威域返回ip
![Pasted image 20250529094833](https://github.com/user-attachments/assets/2c65e357-a173-4713-aa6b-185f95d8b537)

- 协议栈是就是用于整个TCP 、IP的，上面应用层方面socket连接。TCP、UDP就是用于存放HTTP的 head和data。

- get的请求放在了URL上面，而post的请求放在了BODY里面，并非是对get的请求做了限制，而是因为浏览器有这对URL的字符限制。get是将head和body一起发送，然后服务器返回200。post是head和body分开发送，先返回100再返回200。get是幂等性操作，因此不能进行删、改、增操作

- HTTP会通过缓存进行速度优化。强制缓存是指浏览器第一次访问服务器的时候服务器返回的字段中会有缓存字段并设置了缓存过期时间。协商缓存就是和服务器协商之后是否使用本地的缓存。

- HTTP1.0只有短连接，HTTP1.1就含有了长连接。因为有了长连接，所以管道通信就存在了可能，管道通信解决了请求的队头阻塞，但是没有解决响应的队头阻塞

- 对于大量的数据需要传输的话，如果能使用HTTPS 或者HTTP/2那么能提升性能，但是如果都无法使用的话还是会使用HTTPS/1.1 并利用多个TCP

- https是一种加密的传输，因为其含有SSL，从http变成https后端口会从80变成443
![Pasted image 20250530154936](https://github.com/user-attachments/assets/2b4f2c70-4744-4701-ba13-fc51cfa8e1c9)

- 对称加密是同时使用公钥进行加密，非对称是同时使用公用和私用密钥。SSL/TLS协议的基本思路是客户端向服务器索要公钥，然后客户端用公钥加密信息，服务器收到密文后用私钥解密
  在SSL/TLS协议中，非对称加密用于身份验证和密钥交换，而对称加密用于实际数据的加密传输。这种结合利用了非对称加密的安全性和对称加密的效率
  公钥加密私钥解密是为了内容不被泄露，私钥加密公钥解密是为了内容不被冒充
<img width="921" height="1082" alt="image" src="https://github.com/user-attachments/assets/68c32671-2057-4950-b704-97aa4f4cc52e" />
<img width="1002" height="500" alt="image" src="https://github.com/user-attachments/assets/133d3caf-1308-419b-83a2-892e8cc3bff8" />

- cookie的出现主要是http是无状态的协议，cookie将服务器返回的数据存在本地，然后下次发送请求的时候一并发送过去用以身份确认，cookie是在用户端，session是在服务器端，服务器端创建好后会返回给客户端sessionid，然后下次传输就会附带

- 密钥的传递是非对称加密，但是会话是对称加密

- TLS是SSL的后续版本，也是目前的主流版本，它是在建立HTTP连接后的加密方式，它会通过服务器和客户端生成的随机数进而利用公钥私钥产生会话密钥（原因是因为它属于非对称加密，因此只能用公钥加密，私钥解密）

- HTTP1.1相较于HTTP多了长连接，支持管道通信，但是HTTP1.1信息头没有压缩机制，这就使得头部冗余可能导致队列阻塞。HTTP2就多了头部压缩，还将信息报文改成了二进制传输，还有stream从而解决了HTTP1中存在的队头阻塞的问题，但存在TCP层面的阻塞
- ![Pasted image 20250531102743](https://github.com/user-attachments/assets/581fa369-8199-4fb7-8377-1a065806bc70)

- HTTP优化最简单的就是避免HTTP请求，通过缓存可以做到。其次就是减少访问次数（减少重定向--让代理服务器进行消息的传递，合并请求，延迟发送请求）

- RSA握手--首先是客户端发起，带有随机数，然后服务器回答带有随机数和证书，客户端验证继续生成随机数，再服务器收到后生成会话密钥  ECDHE握手

- RSA算法不支持前向保密，因此有了ECDHE的诞生，主要利用了离散对数。ECDHE利用的是椭圆的性质，主要还是利用了公钥和私钥进行加密，公钥用于传递，私钥用于解密

- 硬中断一般是硬件发出，软中断一般是软件发出，硬中断实时性比较高，需要立即响应，软中断响应时间比较长，不是紧急事件

- 粘包是因为TCP是基于字节流的，不是基于消息队列的，因此会随机组合数据，这个可以使用分隔符或者在报文头部加上报文长度等方法解决

- 传统的HTTP1.0每个请求都会建立新的TCP连接，响应完关闭，因此HTTP1.1使用了长连接，允许客户端和服务器保持持久的TCP连接，多个HTTP可以共享同一个连接。需要在connection加入keep-alive。由于有了长连接，因此就有了管道通信，可以一直发，而不是发了需要等待收，但是这个就有可能产生队头阻塞，因为可能某个请求一直接受不到。HTTP/2加了头部压缩的功能，同时将所有文本信息转换成二进制表示方式。HTTP3则是解决了队头阻塞，直接使用UDP进行通信

- ARP是用于ping的时候的播报，ICMP就是用来报状态，类似是否成功

- RSA是非堆成加密方式，如果服务器的私钥泄露了那就会产生很大的危险。ECDHE是一种密钥交换协议，使用椭圆曲线，每次都会重新算一个密钥

- 在Linux中若传输准备工作全部完成就会将数据放入Ring Buffer进行等待，此时出发软中断，网卡开始DMA传输数据，若发送全部结束之后就会触发硬中断并释放内存

- TLS是一种加密通信协议，用的RSA非对称加密

- HTTP是计算密集型，而不是IO密集型，这代表了优化的空间主要在算力
